# 병생프로세스와 세마포어

## 병행성과 병행 프로세스
- 병행성 (concurrency)
  - 여러개의 프로세스 또는 쓰레드가 `동시 수행` 되는 시스템의 특성
- 병행 프로세스
  - 동시 수행되는 여러개의 프로세스 또는 스레드


case 1 1개의 CPU : 인터리빙 형식
- 한개의 CPU가 여러개의 프로세스를 번갈아가면서 실행(Round Robin과 같이)
- CPU가 하나지만 병행 프로세스를 처리할 수있다.
case 2 여러개의 CPU : 병렬처리 형식
- 여러개의 CPU가 프로세스를 병렬처리

### 멀티프로세서 시스템에서의 메모리 구조에 따라
1. 강결합 시스템
- 공유 메모리 구조
- CPU는 여러개지만 `메모리는 하나`다

2. 약결합 시스템
- 분산 메모리 구조
- CPU 마다 메모리를 갖고있다.
- 즉 여러개의 컴퓨터 시스템 이있으며 네트워크로 서로 통신한다.

## 프로세스간 관계
### 독립 프로세스
- 수행 중인 다른프로세스에 영향을 주지도 받지도 않는다.
- 데이터 및 상태를 다른 프로세스와 공유하지 않는다.
- 프로세스의 실행
    - 결정적 :실행결과는 `입력`에 의해서만 결정 됨
    - 재생가능 : `같은 입력`에 대해 `항상 동일`한 실행 결과

### 협력 프로세스
- 수행중인 다른 프로세스와 영향을 주고받음
- 데이터 및 상태를 다른 프로세스와 공유
- 프로세스의 실행
  - 비결정적: 실행결과는 `실행순서`에 좌우됨
  - 재생불가능: 같은 입력에 대해 항상 동일한 실행결과를 보장하지 못한다.

## 병행성 문제
- 협력 프로세스인 겨우 발생 가능한 문제

### 공유 자원(shared resource)
- 시스템 안에서 프로세스나 스레드가 함께 조회할수 있는 변수,메모리,파일 등을 공유 자원이라고 한다.

### 임계 영역(Critical Section)
- 서로다른 프로세스 또는 스레드 등이 `동시에 접근해서는 안되는` `공유 자원` 프로그램 코드 영역
- 프로세스의 접근 순서에 따라 실행 결과가 달라진다.


### 상호배제(mutual exclusion)
- 2개 이상의 프로세스가 동시에 임계 영역을 수행하지 못하도록 하는 것

```
A B 프로세스가 한 계좌를 조회한다고 가정하자.

계좌 잔액 : 5000원 (공유 자원, 임계 영역)

A B 프로세스는 1.계좌조회, 2.입금, 3.계좌 잔액 업데이트 3가지 step으로 동작한다

1. A프로세스가 계좌를 조회 한다.
2. B프로세스가 계좌를 조회 한다.
3. A프로세스가 계좌에 5000원을 입금 한다.
4. B프로세스가 계좌에 10000원을 입금 한다.
5. A프로세스가 계좌에 잔액을 10000원으로 업데이트 한다.
6. B프로세스가 계좌에 잔액을 15000원으로 업데이트 한다..


A B 프로세스에 의해 계좌에 15000원이 입금 되었으므로 실제 계좌 잔액은 20000원이 되어야 한다.
그러나 계좌 잔액은 15000원이 기록되게 된다.

이처럼 임계여역은 상호배제를 통해 다중 프로세스의 접근을 막아야 한다.
```

### 동기화
- 2개 이상의 프로세스에 대한 처리순서를 결정하는 것
- 프로세스 동기화
- 상호배제: 임계영역에 대한 동기화 문제
```

```

### 통신
- 프로세스들이 데이터를 공유하기 위해 반드시 필요
- 프로세스간 통신(IPC)
- 통신방법
  - 하나의 변수 사용(강결합 시스템)
  - 메시지를 서로 주고받음(강결합, 약결합 시스템)

## 세마포어
- 상호배제와 동기화 문제를 해결하기 위한 도구다.
- 세마포어 S는 `정수형` `공용변수`로 `사용 가능한 자원의 수` 또는 `잠김` `풀림` 상태를 값으로 갖는다.
- 기본연산(`primitive operation`) `P`와 `V`에 의해서만 사용될 수 있다.
    - 기본연산: `인터럽트되지 않고` 하나의 단위로 처리 됨 즉 기본연산은 끝날때까지 멈추지 않는다.
- 각각의 세마포어마다 대기 큐가 필요하다

### 연산 P(wait)
- 검사, 감소시키려는 시도
- 세마포어 S 값이 0 이상의 정수 (사용 가능한 자원이 있다) 면 1 감소시킨다.
- 세마포어 S 값이 0 이면 현재 프로세스를 `대기 큐`로 전이시킨다.
- `down` 또는 `wait` 등으로 불리기도 한다.

```
void P(semaphore s)
{
    if (s > 0)
        s--;//s값 감소시킴
    else
        현재 프로세스를 대기시킴;(레디 큐에 넣는다.)
}

```

### 연산 V
- 증가 시키려는 시도
- 대기 큐가 비어있다면 세마포어 s 값을 1 증가시킨다.
- 대기 큐가 비어있지 않다면 대기큐에서 프로세스 하나를 진행시킨다.

```
void V(semaphore s)
{
    if (대기 중인 프로세스 없음)//연산 P에 의해 대기중인것이 있는지 확인
        s++;//s값 증가 시킴
    else
        현재 프로세스 1개를 진행;//연산 P에 의해 대기중인것중 하나를 진행시킴
}

```

## Busy wait(spin lock) 방식 Semaphore
```
semaphore mutex, 초기값이 1인 세마포어
do{
    P(mutex) //세마포어 mutex 1 감소 0일경우 wait
    critical section
    V(mutex) //세마포어 mutex 1 증가
}


```


## Block/ Wakeup Implementation
- semaphore를 다음과 같이 정의
```
typedef struct
{
int value;//semaphore
struct process *L//process wait queue
}semaphore

```
- block 과 wakeup을 다음과 같이 가정
#### block
- 커널은 block 을 호출한 프로세스를 suspend 시킴
- 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음
#### wakeup(P)
- block 된 프로세스 P를 wakeup 시킴
- 이프로세스의 PCB를 ready queue로 옮김

### Block/ Wakeup P, S 연산
```
P(S): S.value --;//S는 세마포어 변수
      /세마포어 변수가 음수면 프로세스를 block 시킨다
      if(S.value <0)/
      {
        add this process to S.L;
        block()
      }

```
- S.value의 의미
- busy wation은 단순히 자원의 개수였다
- block/wakeup 에서는
  - 음수일 경우 block된 프로세스가 있다는 의미(기다리는 프로세스가 있다.)
  - 양수일 경우 block된 프로세스가 없다는 의미(기다리는 프로세스가 없다.)

```
V(S): S.value++;
      if(S.value <=0){
        remove a process P from S.L;
        wakeup(P);
      }


```


### Busy wait vs Block/Wake up
- critical section의 길이가 긴 경우 Block/Wake up이 유리
- critical section의 길이가 매우 짧은 경우 Block/Wakeup 오버헤드가 busy-wait 오버헤드보다 더 커질 수 있음
- 일반적으로  Block/Wake up 방식이 더 좋다.

## 세마포어의 종류
1. counting semaphore
- 도메인이 0 이상인 임의의 정수값
- 주로 resource counting에 사용
2. binary semaphore(=mutex)
- 0또는 1값만 가질수 있는 semaphore
- 주로 mutal exclusion (lock/unlock) 에 이용


## 세마포어로 상호배제 해결 방법
### 상호 배제를위한 일반적인 요구사항
1. 임계 영역에 한 프로세스가 수행중이면 다른 프로세스는 임계영역에 진입 할 수 없다.
2. 임계 영역에 수행중인 프로세스가 임계영역을 벗어 나면 다른 프로세스 또는 스레드가 임계영역에 진입 할 수 있어야 한다.
3. 준비 큐에 있는 프로세스 또는 스레드가 `적절한 시간` 내에 임계영역에서 작업을 수행할 수 있어야 한다. (무한대기 문제 방지)

### 진입영역과 해제영역
- 진입영역
  - 임계영역에 대한 후생을 해도 되는지 체크
  - 연산P를 둔다.
- 해제 영역
  - 다른 프로세스가 임계영역 수행을 시작할 수 있도록 함
  - 연산V를 둔다.

### 해결 예시
- 프로세스는 진입영역을 거쳐 임계영역으로 진입한다.
- 임계영역에서 작업수행이 끝나면 해제영역으로 진입한다.
- 세마포어 s는 mutex(자원이 1인 상태)다.
```
//semaphore mutex: 초기값을 1로 지정
진입영역 :P
해제영역 :V
대기큐는 FIFO(선입선출)로 동작

do{
진입영역 P(mutex)

임계영역 critical section

해제 영역 V(mutex)
}while(1);
```
1. 프로세스 A가 진입, P호출 세마포어값 1로 세마포어 값을 0으로 할당후 임계영역에서 작업 수행
2. 프로세스 B가 진입, P호출 세마포어값 0 이므로 대기큐 진입
2. 프로세스 C가 진입, P호출 세마포어값 0 이므로 대기큐 진입
4. 프로세스 A가 임계영역 수행을 끝냄 V호출, 대기큐에 프로세스가 할당되어 있으므로 프로세스 B 임계영역에서 작업 수행
4. 프로세스 B가 임계영역 수행을 끝냄 V호출, 대기큐에 프로세스가 할당되어 있으므로 프로세스 C 임계영역에서 작업 수행
5. 프로세스 C가 임계영역 수행을 끝냄 V호출, 대기큐에 프로세스가 없으므로 세마포어값 1증가시킴


## 세마포어로 동기화 문제 해결
- 세마포어를 통해 동기화(프로세스간 수행 순서) 문제를 해결 할 수 있다.
- 먼저 실행되어야 하는 프로세스 또는 스레드에 뒤에 연산 V를 놓는다.
- 나중에 실행되어야 하는 프로세스 또는 스레드 앞에 연산 P를 놓는다.
- 프로세스 A가 입금 프로세스, 프로세스 B가 계좌 잔액 업데이트 프로세스로 가정하자
- 프로세스 A가 먼저 수행되어야 하며, 프로세스 B는 A의 수행이 끝난 후 수행되어야 한다.
```
세마포어 sync의 초기값은 0

                    
프로세스 A         P(sync)
  V(sync)         프로세스 B


```
#### Case1 프로세스 A가 먼저 호출되는 경우
1. 프로세스 A가 호출되어 작업을 수행한다.
2. 프로세스 A작업이 끝나면 연산 V(sync)를 수행, 대기 큐가 비었으므로 세마포어 값을 1 증가시킨다.
3. 프로세스 B가 호출되어 연산 P(sync)를 수행, 세마포어 값이 1 이므로 세마포어 값을 1 감소시킨 후 작업을 수행한다.

#### Case2 프로세스 B가 먼저 호출되는 경우
1. 프로세스 B가 호출되어 연산 P(sync)를 수행, 세마포어 값이 0 이므로 대기큐로 전이 된다.
2. 프로세스 A가 호출되어 작업을 수행한다.
3. 프로세스 A작업이 끝나면 연산 V(sync)를 수행, 대기 큐의 프로세스 B를 호출한다.
4. 프로세스 B가 작업을 수행한다.


## 생산자 소비자 문제(Producer-Consumer Problem)
- 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제
- 버퍼가 `유한한` 상황에서 발생하는 문제로 Bounded-Buffer Problem로 불리기도 한다.

### 개념
#### 생산자(Producer)
- 데이터를 버퍼에 넣는 프로세스
1. 버퍼에 공간이 없으면 대기한다.(세마포어 이용)
2. 버퍼에 공간이 있으면 lock을 걸고(세마포어 이용) 데이터를 입력한다.
3. 작업이 끝나면 lock을 푼다
4. buffer를 1 증가시킨다.
#### 소비자(Comsumer)
- 데이터를 버퍼에서 꺼내는 프로세스
1. 버퍼가 있는지 확인하여 버퍼가 없으면 대기한다.(세마포어 이용)
2. 버퍼가 있으면 lock을 건다(세마포어 이용)
3. 버퍼에서 데이터를 꺼낸다.
4. 작업이 끝나면 lock을 푼다
5. buffer를 1 감소시킨다. 

#### 버퍼(Buffer)
- 데이터를 `임시`로 저장하는 `공유 공간(shared memory)`, 소비자가 `소비한 데이터`는 `삭제` 하여 공간을 확보한다.

### 버퍼에 여러 프로세스가 동시에 접근할 수 없어야 한다.
  - 생산자가 버퍼에 데이터를 넣는 동안에 소비자는 데이터를 꺼낼수 없어야 한다.(lock)
  - 소비자가 데이터를 꺼내는 동안에는 생산자는 버퍼에 데이터를 넣을수 없어야 한다.(lock)
  - 생산자 소비자 프로세스간 `상호배제` 필요
### 버퍼의 크기는 유한하다(유한 버퍼 문제)
  - `버퍼가 가득찬 경우` 생산자는 데이터를 넣지 말고 `대기`해야 한다.
  - `버퍼가 비어있는 경우` 소비자는 데이터를 꺼내지 말고 `대기`해야 한다.
  - 프로세스간 `동기화` 필요

## 세마포어를 이용한 생산자 소비자 문제 해결
### 1. 상호배제 문제 해결
- 세마포어 mutex(초기값 1인 세마포어)로 해결
- 먼저 접근한 프로세스가 버퍼에 접근할수 있고 뒤에 접근한 프로세스는 대기큐로 전이된다.
```
생산자의 코드

While(true){
    데이터를 생산

    P(mutex);
    버퍼에 데이터를 넣음 //임계영역
    V(mutex)

}


소비자의 코드

While(ture){
    P(mutex)
    버퍼에서 데이터를 꺼냄
    V(mutex)

    데이터를 소비


}

```

### 2. 동기화 문제 해결
#### Case1 버퍼가 가득찬 경우
- 세마포어 empty(초기값 n, n은 버퍼의 크기)
- 버퍼가 가득찬 경우 (세마포어 empty의 값이 0이된 경우), 생산자는 P(empty)연산 에 의해 대기큐로 전이된다.
- 소비자는 버퍼가 가득차도 버퍼에서 데이터를 꺼낼 수 있으며, 소비자가 데이터 사용후 삭제함으로써 버퍼의 `빈공간`이 확보된다.

```

While(true){
    데이터를 생산

    P(empty);//버퍼가 꽉차 세마포어 empty가 0이면 대기큐로 전이된다.

    P(mutex);
    버퍼에 데이터를 넣음 //임계영역
    V(mutex)

}


소비자의 코드

While(ture){
    P(mutex)
    버퍼에서 데이터를 꺼냄
    V(mutex);

    V(empty);
    데이터를 소비

}

```

#### Case2 버퍼가 비어있는 경우
- 세마포어 full (초기값 0)
- 버퍼가 비어있는 경우 생산자가 버퍼에 접근시 연산자P(full)에 의해 대기큐로 전이된다.
- 생산자는 버퍼에 데이터를 추가하고 연산자V(full) 에 의해 소비자가 호출된다.

```
생산자의 코드
While(true){
    데이터를 생산

    P(empty);//세마포어 empty 확인, (비어있는 버퍼수 확인)

    P(mutex);
    버퍼에 데이터를 넣음 //임계영역
    V(mutex);

    V(full);//세마포어 full 1 증가 (버퍼수 1 증가)

}


소비자의 코드

While(ture){
    P(full); //버퍼가 비어있는 경우 세마포어 full==0, 소비자는 대기큐로 전이된다.

    P(mutex)
    버퍼에서 데이터를 꺼냄
    V(mutex)
    
    V(empty);

}

```

### 결론
- 3개의 세마포어 mutex(초기값 1) empty(초기값 n, n은 버퍼의크기) full(초기값 0) 으로 `상호배제`, `동기화 문제` 해결


## 판독기 - 기록기 문제(Reader-Writer Problem)
- 여려 협력 프로세스 사이에 공유자원을 두고 판독기와 기록기의 상황을 다루는 문제
- 판독기(Reader): 데이터를 읽기만 하는 프로세스나 스레드
- 기록기(Writer) : 데이터를 기록하는 프로세스나 스레드

### 기록기가 공유자원에 접근시 다른 기록기,판독기는 접근할 수 없다.
- 공유자원에 `데이터를 쓰는(write)` 동안에는 누구도 접근할 수 없음
    - 공유자원에서 데이터를 읽는 동안에는 데이터를 쓸 수 없음
    - `상호배제 필요`
### 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있음
- 판독기가 읽는 중 새로운 판독기 읽기 시도 ->가능
- 판독기가 읽는 중 기록기 대기 ->새로운 판독기 읽기 시도 -> 가능/불가능?


## 제1판독기 기록기 문제
- 판독기가 공유자원에 접근 중이라면 기록기보다 `판독기` 에 우선순의를 줌
- 즉 새로운 판독기는 즉시 공유자원에 접근 가능하다.
- 문제점 : `기록기`의 `기아상태 유발` 가능(무한 대기 문제)

### 세마포어를 이용한 해결
- 상호배제: 세마포어 wrt
- 판독기 우선 :일반변수 rcount, 읽으려고하는 판독기의 갯수 초기값 0, 세마포어 mutex
- 판독기 우선을 위해 도입한  판독기의 일반변수, 세마포어 wrt는 임계 영역으로 봐야 한다. 즉 상호배제가 필요하다.
- 앞서 문제들과 마찬가지로 세마포어 mutex(초기값 1) 을 적용하여 상호배제 문제를 해결해 준다.(rcount를 증가, 감소시키는 부분은 한번에 하나의 판독기만 호출할 수 있음)
```
rcount= rcount +1;
if (rcount ==1) P(wrt);

```
```

기록기의 코드

P(wrt);
공유자원에 쓰기
V(wrt);

판독기의 코드

P(mutex);
rcount= rcount +1;
if (rcount ==1) P(wrt);
V(mutex)

공유자원에서 읽기

rcount = rcount - 1;
if (rcount ==0) V(wrt)



```

## 제 2 판독기 기록기 문제
- 판독기가 공유자원에 접근 중이라면 판독기보다 기록기에 우선순위를 줌
- 문제점
  - 판독기의 병행성이 떨어짐
  - 판독기의 `기아상태` 유발 가능(기록기가 무한하다면? 판독기는 무한하게 대기해야함)


```
mutex1 - rcount(공유 자원 읽기를 진행중인 프로세스 수) 접근을을 위한 상호배제 세마포어
mutex2 - wcount(공유 자원 쓰기를 진행중인 프로세스 수) 접근을 위한 상호배제 세마포어
wrt - 공유자원에 "쓰기" 작업 진행을 위한 상호배제 세마포어
rd - 기록기가 실행중일때 판독기의 접근을 막는 세마포어, rd==0 이여야 판독기의 접근이 가능하다.

```
```
기록기의 코드

P(mutex2)
wcount = wcount + 1;
if (wcount ==1) P(rd); //P(rd) 기록기가 실행중일때 판독기의 접근을 막음
V(mutex2);

P(wrt);
공유자원에 쓰기
V(wrt);

P(mutex2);
wcount = wcount -1;
if (wcount ==0) V(rd)
V(mutex2)
```



```
판독기의 코드

P(mutex3);
P(rd);

//rcount 관련 세마포어(mutex1)
P(mutex1);// rcount 접근을 위한 상호배제역할의 세마포어(lock을 건다)
rcount= rcount +1;//read 작업을 시작하므로 rcount 1 를증가시킨다.
if (rcount ==1) P(wrt);
V(mutex1);// rcount lock 해제

V(rd);
V(mutex3);

공유자원에서 읽기

//rcount 관련 코드들
P(mutex1);//rcount를 변경하기 위한 상호배제역할의 세마포어
rcount = rcount - 1;//read 작업이 끝났으므로 rcount 1 감소
if (rcount ==0) V(wrt)
V(mutex1)


```


## semaphore의 문제점
- 코딩하기 힘들다
- 정확성(correctness) 입증이 어렵다
- 한번의 실수가 시스템에 치명적 영향을 끼친다.(deadlock 유발, mutual exclusion 깨짐)

## Monitor
- 프로그래밍 언어 레벨에서 제공되는 추상화된 동기화(synchroniztion) 구조
- lock을 걸지 않아도 된다.
- 모니터 내에서는 한번에 하나의 프로세스만 활동 가능
- 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없다
### contdition variable
- 프로세스가 모니터 안에서 기다릴 수 있도록 하기 위한 변수
- condition variable은 wait(), signal()연산에 의해서만 접근 가능하다.
```
condition x
wait 연산

x.wait()을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke 하기 전까지 suspend 된다.

x.signal()은 정확하게 하나의 suspend된 프로세스를 resume 한다.
suspend된 프로세스가 없으면 아무일도 일어나지 않는다.

```

```
monitor bounded_buffer
{ int buffer[N];
  condition full, empty//full은 데이터가 있는 버퍼를,  empty는 빈 버퍼를 기다리는 프로세스를 줄세우는 condition 변수


  void produce(int x)
  { if ther is no empty buffer
      empty.wait();//빈버퍼를 기다리는 큐로 들어감
    add x to an empty buffer
    full.signal();
  }


  void consume (int *x)
  { if ther is no full buffer
      full.wait();//데이터가 차길 기다리는 큐에 들어감
    remove an item from buffer and sotre it to *x
    empty.signal()//empty 큐에서 프로세스를 깨움
  }



}


```
